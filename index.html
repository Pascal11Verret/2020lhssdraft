<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Repêchage LHSS 2020</title>
    
    <!-- Firebase SDKs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-app-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-database-compat.min.js"></script>
    
    <!-- Papa Parse pour CSV -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    
    <style>
        /* Styles généraux */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e40af 0%, #3b82f6 25%, #dc2626 75%, #991b1b 100%);
            color: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 3rem;
            background: linear-gradient(45deg, #fbbf24, #f97316);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        /* Styles du logo */
        .draft-logo {
            display: inline-block;
            margin: 20px 0;
            position: relative;
        }

        .lhss-draft-logo {
            width: 400px;
            height: 120px;
            max-width: 90vw;
        }

        @media (max-width: 768px) {
            .lhss-draft-logo {
                width: 300px;
                height: 90px;
            }
        }

        /* Styles du formulaire de connexion et de configuration Firebase */
        .login-form {
            max-width: 400px;
            margin: 50px auto;
            background: rgba(31, 41, 55, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
        }

        /* Styles des contrôles et boutons */
        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 30px;
            align-items: center;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            color: white;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary { background: linear-gradient(45deg, #3b82f6, #8b5cf6); }
        .btn-success { background: linear-gradient(45deg, #10b981, #059669); }
        .btn-danger { background: linear-gradient(45deg, #ef4444, #dc2626); }
        .btn-warning { background: linear-gradient(45deg, #f59e0b, #d97706); }

        .btn:hover { transform: translateY(-2px); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Styles de la grille principale */
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 1200px) {
            .grid { grid-template-columns: 1fr 1fr; }
        }

        @media (max-width: 768px) {
            .grid { grid-template-columns: 1fr; }
            .controls { flex-direction: column; }
        }

        /* Styles des panneaux */
        .panel {
            background: rgba(31, 41, 55, 0.9);
            border-radius: 15px;
            padding: 25px;
            max-height: 600px;
            overflow-y: auto;
        }

        .panel h2 {
            font-size: 1.5rem;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Styles des champs de saisie et de sélection */
        .search-input, .select-input {
            width: 100%;
            padding: 10px;
            background: rgba(55, 65, 81, 1);
            border: 1px solid #4b5563;
            border-radius: 8px;
            color: white;
            margin-bottom: 15px;
        }

        .search-input:focus, .select-input:focus {
            outline: none;
            border-color: #3b82f6;
        }

        /* Styles de la liste des joueurs */
        .player-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .player-item {
            background: rgba(55, 65, 81, 1);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }

        .player-item:hover {
            background: rgba(75, 85, 99, 1);
        }

        .player-item.selected {
            background: #3b82f6;
            border-color: #60a5fa;
        }

        .player-item.drafted {
            opacity: 0.5;
            background: rgba(55, 65, 81, 0.5);
            cursor: not-allowed;
        }

        .player-name {
            font-weight: bold;
            font-size: 1.1rem;
        }

        .player-details {
            color: #d1d5db;
            font-size: 0.9rem;
            margin-top: 5px;
        }

        .player-potential {
            display: inline-block;
            background: #fbbf24;
            color: #000;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: bold;
            margin-left: 5px;
        }

        .player-precision {
            display: inline-block;
            background: #3b82f6;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: bold;
            margin-left: 5px;
        }

        .player-stats {
            float: right;
            display: flex;
            gap: 5px;
        }

        /* Styles des résultats du repêchage */
        .draft-result {
            background: rgba(55, 65, 81, 1);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between; 
            align-items: center;
        }

        .team-selector {
            background: rgba(31, 41, 55, 1);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        /* Styles de chargement */
        .loading {
            text-align: center;
            padding: 40px;
            color: #9ca3af;
        }

        .spinner {
            border: 3px solid #374151;
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Indicateur de statut de connexion */
        .status-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9rem;
            z-index: 1000;
        }

        .status-admin {
            background: #10b981;
        }

        .status-viewer {
            background: #3b82f6;
        }

        .status-connecting {
            background: #f59e0b;
        }

        .status-offline {
            background: #ef4444;
        }

        /* Styles des tableaux */
        .table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 0.75rem;
        }

        .table th, .table td {
            padding: 6px 4px;
            border: 1px solid #4b5563;
            text-align: left;
            word-wrap: break-word;
            max-width: 120px;
        }

        .table th {
            background: rgba(55, 65, 81, 1);
            font-weight: bold;
            font-size: 0.7rem;
        }

        @media (max-width: 768px) {
            .table {
                font-size: 0.65rem;
            }
            
            .table th, .table td {
                padding: 4px 2px;
                max-width: 80px;
            }
        }

        .auto-refresh {
            font-size: 0.8rem;
            color: #9ca3af;
            text-align: center;
            margin-top: 10px;
        }

        /* Styles du timer */
        .timer-controls {
            background: rgba(31, 41, 55, 1);
            border: 2px solid #4b5563;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .timer-controls h3 {
            text-align: center;
        }

        .timer-display {
            text-align: center;
        }

        .timer-controls .btn {
            font-size: 0.8rem;
            padding: 8px 12px;
        }

        /* Styles spécifiques à l'ordre de repêchage */
        #draftOrderPanel {
            background: rgba(31, 41, 55, 0.95);
            border: 1px solid #4b5563;
        }
        
        #draftOrderTable .pick-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background-color: rgba(55, 65, 81, 0.8);
            border-bottom: 1px solid #4b5563;
            cursor: grab; /* Indique la possibilité de glisser */
            transition: background-color 0.2s ease-in-out;
        }

        #draftOrderTable .pick-item:last-child {
            border-bottom: none;
        }

        #draftOrderTable .pick-item:hover {
            background-color: rgba(75, 85, 99, 0.8);
        }

        #draftOrderTable .pick-item.dragging {
            opacity: 0.7;
            background-color: rgba(99, 102, 241, 0.8); /* Surligne lors du glisser */
        }

        #draftOrderTable .pick-item span {
            flex: 1;
            text-align: left;
        }
        
        #draftOrderTable .pick-item .pick-number {
            font-weight: bold;
            min-width: 60px; /* Assure une largeur constante */
        }

        #draftOrderTable .pick-item .team-name {
            color: #60a5fa;
            font-weight: bold;
        }

        #currentPicker {
            border: 2px solid #10b981;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { border-color: #10b981; }
            50% { border-color: #34d399; }
        }

        .expired-timer {
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        .hidden {
            display: none !important;
        }

        /* Styles de la configuration Firebase */
        .firebase-setup {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid #ef4444;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .firebase-setup h3 {
            color: #fbbf24;
            margin-bottom: 10px;
        }

        /* Styles du statut de connexion */
        .connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
            padding: 5px 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .connection-status.connected {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }

        .connection-status.disconnected {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .connection-status.connecting {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
        }
    </style>
</head>
<body>
    <!-- Indicateur de statut global -->
    <div id="statusIndicator" class="status-indicator status-connecting">
        <span id="statusText">Connexion...</span>
    </div>

    <!-- Section de configuration Firebase -->
    <div id="firebaseSetup" class="login-form hidden">
        <h2>🔧 Configuration Firebase</h2>
        <div class="firebase-setup">
            <h3>Instructions de configuration :</h3>
            <ol style="text-align: left; margin-bottom: 15px; color: #d1d5db;">
                <li>Créez un projet Firebase sur <a href="https://console.firebase.google.com" target="_blank" style="color: #60a5fa;">console.firebase.google.com</a></li>
                <li>Activez Realtime Database</li>
                <li>Copiez la configuration et collez-la ci-dessous</li>
            </ol>
        </div>
        
        <textarea id="firebaseConfig" placeholder='Collez votre configuration Firebase ici, exemple:
{
  "apiKey": "AIzaSyBXrY5MIuqN5kH_jcnezC71rSeb0pr_Sms",
            "authDomain": "lhssdraft.firebaseapp.com",
            "databaseURL": "https://lhssdraft-default-rtdb.firebaseio.com",
            "projectId": "lhssdraft",
            "storageBucket": "lhssdraft.firebasestorage.app",
            "messagingSenderId": "441205645400",
            "appId": "1:441205645400:web:85d8c86c9a77891b916a2d",
            "measurementId": "G-N7RN68KTND"
}'
            style="width: 100%; height: 150px; margin-bottom: 15px; padding: 10px; background: rgba(55, 65, 81, 1); border: 1px solid #4b5563; border-radius: 8px; color: white; font-family: monospace; font-size: 0.8rem;"></textarea>
        
        <button onclick="initializeFirebase()" class="btn btn-primary" style="width: 100%; margin-bottom: 10px;">
            🚀 Initialiser Firebase
        </button>
        
        <button onclick="useLocalMode()" class="btn btn-warning" style="width: 100%; margin-bottom: 10px;">
            📱 Mode Local (sans synchronisation)
        </button>
        
        <button onclick="showLoginForm()" class="btn btn-primary" style="width: 100%;">
            ← Retour à la connexion
        </button>
        
        <div style="margin-top: 15px; font-size: 0.8rem; color: #9ca3af;">
            <strong>Mode Local:</strong> Les données ne seront pas synchronisées entre utilisateurs
        </div>
    </div>

    <!-- Formulaire de connexion -->
    <div id="loginForm" class="login-form">
        <h2>🏒 Repêchage LHSS 2020</h2>
        
        <div id="connectionStatus" class="connection-status connecting">
            <span>🔄</span>
            <span>Connexion à Firebase...</span>
        </div>
        
        <p style="margin-bottom: 20px; color: #9ca3af;">
            Choisissez votre mode d'accès
        </p>
        
        <div style="margin-bottom: 20px;">
            <input type="password" id="adminPassword" placeholder="Mot de passe admin" 
                   class="search-input" style="margin-bottom: 10px;">
            <button onclick="loginAsAdmin()" class="btn btn-primary" style="width: 100%; margin-bottom: 10px;">
                Connexion Admin
            </button>
        </div>
        
        <div style="margin-bottom: 20px;">
            <select id="viewerTeamSelect" class="select-input" style="width: 100%; margin-bottom: 10px;">
                <option value="">Sélectionnez votre équipe (Spectateur)</option>
                </select>
            <button onclick="loginAsViewer()" class="btn btn-success" style="width: 100%;">
                Accès Spectateur (Lecture seule)
            </button>
        </div>
        
        <button onclick="showFirebaseConfig()" class="btn btn-warning" style="width: 100%; margin-top: 10px; font-size: 0.9rem;">
            ⚙️ Configuration Firebase (Admin uniquement)
        </button>
        
        <div style="margin-top: 20px; font-size: 0.8rem; color: #9ca3af;">
            <strong>Mode Admin:</strong> Mot de passe = "lhss2020"<br>
            <strong>Mode Spectateur:</strong> Voir les résultats en temps réel pour votre équipe
        </div>
    </div>

    <!-- Application principale -->
    <div id="mainApp" class="container hidden">
        <div class="header">
            <h1>🏒 Repêchage LHSS 2020</h1>
            
            <!-- Logo LHSS Draft -->
            <div class="draft-logo">
                <svg class="lhss-draft-logo" viewBox="0 0 400 120" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <linearGradient id="blueGrad" x1="0%" y1="0%" x2="100%" y2="0%">
                            <stop offset="0%" style="stop-color:#1e40af;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#3b82f6;stop-opacity:1" />
                        </linearGradient>
                        <linearGradient id="redGrad" x1="0%" y1="0%" x2="100%" y2="0%">
                            <stop offset="0%" style="stop-color:#dc2626;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#b91c1c;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    
                    <g transform="translate(60, 30)">
                        <path d="M0 15 L0 0 L250 0 Q270 0 280 10 L290 25 Q295 40 280 50 L250 60 L0 60 Z" 
                                fill="url(#blueGrad)" stroke="#fff" stroke-width="2"/>
                        <text x="140" y="40" text-anchor="middle" fill="white" font-family="Arial Black" font-size="32" font-weight="bold">DRAFT</text>
                    </g>
                    
                    <g transform="translate(80, 70)">
                        <path d="M0 10 L180 10 Q200 10 210 20 L220 30 Q225 35 215 40 L200 45 L0 45 Q-10 45 -5 35 L0 25 Z" 
                                fill="url(#redGrad)" stroke="#fff" stroke-width="2"/>
                        <text x="110" y="32" text-anchor="middle" fill="white" font-family="Arial Black" font-size="16" font-weight="bold">2020</text>
                    </g>
                    
                    <g transform="translate(320, 20)">
                        <polygon points="20,5 25,15 35,15 27,22 30,32 20,25 10,32 13,22 5,15 15,15" 
                                 fill="#fbbf24" stroke="#fff" stroke-width="1"/>
                        <polygon points="45,35 48,42 55,42 50,47 52,54 45,50 38,54 40,47 35,42 42,42" 
                                 fill="#e5e7eb" stroke="#fff" stroke-width="1"/>
                    </g>
                </svg>
            </div>
            
            <p id="roundInfo">Ronde 1 - Choix #1</p>
            <div id="connectionStatusMain" class="connection-status connecting" style="display: inline-flex; margin-top: 10px;">
                <span>🔄</span>
                <span>Synchronisation...</span>
            </div>
        </div>

        <!-- Contrôles administrateur -->
        <div id="adminControls" class="controls hidden">
            <!-- Contrôles du timer -->
            <div class="timer-controls" style="background: rgba(31, 41, 55, 1); padding: 15px; border-radius: 8px; margin-bottom: 15px; text-align: center;">
                <h3 style="margin-bottom: 10px; color: #fbbf24;">⏱️ Compte à Rebours</h3>
                <div id="timerDisplay" style="font-size: 2rem; font-weight: bold; color: #60a5fa; margin-bottom: 10px;">05:00</div>
                <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-bottom: 10px;">
                    <input type="number" id="timerMinutes" placeholder="Minutes" min="1" max="60" value="5" 
                            style="width: 80px; padding: 5px; background: rgba(55, 65, 81, 1); border: 1px solid #4b5563; border-radius: 4px; color: white; text-align: center;">
                    <button onclick="setTimer()" class="btn btn-primary" style="padding: 5px 10px; font-size: 0.9rem;">Définir</button>
                    <button onclick="startTimer()" class="btn btn-success" style="padding: 5px 10px; font-size: 0.9rem;" id="startTimerBtn">Start</button>
                    <button onclick="pauseTimer()" class="btn btn-warning" style="padding: 5px 10px; font-size: 0.9rem;" id="pauseTimerBtn">Pause</button>
                    <button onclick="resetTimer()" class="btn btn-danger" style="padding: 5px 10px; font-size: 0.9rem;">Reset</button>
                </div>
            </div>

            <button onclick="exportToCSV()" class="btn btn-success">
                💾 Exporter CSV
            </button>
            
            <label class="btn btn-primary">
                📁 Importer Joueurs CSV
                <input type="file" accept=".csv" onchange="importPlayers(event)" style="display: none;">
            </label>
            
            <label class="btn btn-warning">
                📋 Importer Ordre CSV
                <input type="file" accept=".csv" onchange="importDraftOrder(event)" style="display: none;">
            </label>
            
            <button onclick="resetDraft()" class="btn btn-danger">
                🔄 Réinitialiser
            </button>
            
            <div class="team-selector">
                <label style="margin-right: 10px;">Équipe:</label>
                <select id="teamSelect" class="select-input" style="width: auto; margin: 0;">
                    </select>
            </div>
            
            <button onclick="skipPick()" class="btn btn-warning" id="skipBtn">
                ⏭️ Passer le tour
            </button>
            
            <div style="background: rgba(31, 41, 55, 1); padding: 10px 15px; border-radius: 8px; font-size: 0.9rem;">
                <span id="playerCount">Joueurs disponibles: 0 / 0</span>
            </div>
        </div>

        <!-- Informations pour le mode spectateur -->
        <div id="viewerInfo" class="hidden" style="text-align: center; margin-bottom: 20px; color: #9ca3af;">
            <p>Mode spectateur - Les données se synchronisent automatiquement en temps réel</p>
            <p style="font-size: 0.9rem; margin-top: 5px;">💡 Cliquez sur un joueur pour voir ses détails. Utilisez les filtres pour naviguer plus facilement.</p>
            <div id="viewerTeamDisplay" style="font-size: 1.1rem; font-weight: bold; margin-top: 10px; color: #fbbf24;"></div>
            <div class="timer-display" style="background: rgba(31, 41, 55, 1); padding: 15px; border-radius: 8px; margin-top: 15px;">
                <h3 style="margin-bottom: 10px; color: #fbbf24;">⏱️ Temps Restant</h3>
                <div id="timerDisplayViewer" style="font-size: 2rem; font-weight: bold; color: #60a5fa;">05:00</div>
                <div id="timerStatusViewer" style="font-size: 0.9rem; color: #9ca3af; margin-top: 5px;">En attente</div>
            </div>
        </div>

        <!-- Panneau de l'ordre de repêchage -->
        <div id="draftOrderPanel" class="panel">
            <h2>📋 Ordre de Repêchage</h2>
            <!-- Contrôles admin pour l'ordre de repêchage -->
            <div id="adminDraftOrderControls" class="controls hidden" style="margin-bottom: 15px;">
                <input type="number" id="swapPick1" placeholder="Choix 1" class="search-input" style="width: 100px; margin-bottom: 0;">
                <input type="number" id="swapPick2" placeholder="Choix 2" class="search-input" style="width: 100px; margin-bottom: 0;">
                <button onclick="swapDraftPicks()" class="btn btn-primary" style="flex-grow: 1; margin-bottom: 0;">Échanger les choix</button>
                <button onclick="resetDraftOrder()" class="btn btn-danger" style="flex-grow: 1; margin-bottom: 0;">Réinitialiser l'ordre</button>
            </div>
            <div id="currentPicker" style="background: rgba(55, 65, 81, 1); padding: 15px; border-radius: 8px; margin-bottom: 15px; text-align: center;">
                <h3 style="color: #fbbf24; margin-bottom: 5px;">Tour Actuel</h3>
                <div style="font-size: 1.2rem; font-weight: bold; color: #60a5fa;" id="currentPickerText">
                    Ronde 1 - Choix #1
                </div>
                <div style="font-size: 1rem; color: #10b981; margin-top: 5px;" id="currentTeamText">
                    En attente de l'ordre...
                </div>
            </div>
            <div id="draftOrderTable">
                <div class="loading">
                    <p>Importez un fichier CSV avec l'ordre de repêchage</p>
                    <div style="margin-top: 10px; font-size: 0.8rem; color: #9ca3af;">
                        Format: Ronde, Choix, Équipe
                    </div>
                </div>
            </div>
        </div>

        <!-- Grille des panneaux (Joueurs, Détails, Résultats) -->
        <div class="grid">
            <!-- Panneau des joueurs disponibles -->
            <div id="playersPanel" class="panel">
                <h2>
                    👥 Joueurs Disponibles (<span id="availableCount">0</span>)
                </h2>
                
                <!-- Filtres de recherche -->
                <div id="searchFilters">
                    <input type="text" id="searchInput" placeholder="Rechercher un joueur..." class="search-input">
                    <select id="positionFilter" class="select-input">
                        <option value="">Toutes les positions</option>
                    </select>
                </div>
                
                <div id="playersLoading" class="loading">
                    <div class="spinner"></div>
                    <p>Chargement des joueurs...</p>
                </div>
                
                <div id="playersList" class="player-list"></div>
            </div>

            <!-- Panneau des détails du joueur -->
            <div id="playerDetailsPanel" class="panel">
                <h2>📋 Détails du Joueur</h2>
                <div id="playerDetails">
                    <div class="loading">
                        <p>Sélectionnez un joueur pour voir ses détails</p>
                    </div>
                </div>
            </div>

            <!-- Panneau des résultats du repêchage -->
            <div class="panel">
                <h2>🏆 Résultats du Repêchage</h2>
                <div id="draftResults">
                    <div class="loading">
                        <p>Aucun joueur repêché</p>
                    </div>
                </div>
                <div class="auto-refresh">
                    Synchronisation temps réel avec Firebase
                </div>
            </div>
        </div>

        <!-- Tableau récapitulatif du repêchage -->
        <div id="draftSummary" class="panel" style="margin-top: 30px;">
            <h2>📊 Tableau Récapitulatif</h2>
            <div id="summaryTable"></div>
        </div>
    </div>

    <script>
        // Variables globales
        let players = []; // Liste de tous les joueurs
        let draftResults = []; // Résultats des choix de repêchage
        let draftOrder = []; // Ordre de repêchage
        let selectedPlayer = null; // Joueur actuellement sélectionné dans l'interface
        let currentRound = 1; // Ronde actuelle du repêchage
        let currentPick = 1; // Choix actuel dans la ronde
        let isAdmin = false; // Indique si l'utilisateur est un administrateur
        let selectedTeam = 'Capitals'; // Équipe sélectionnée pour l'admin
        let viewerSelectedTeam = ''; // Équipe sélectionnée pour le mode spectateur
        let database = null; // Instance de la base de données Firebase
        let firebaseApp = null; // Instance de l'application Firebase
        let isConnected = false; // Statut de connexion à Firebase
        let useLocalStorage = false; // Indique si le mode local est actif
        
        // Variables pour le compte à rebours
        let timerDuration = 300; // Durée par défaut du timer (5 minutes en secondes)
        let timerRemaining = 300; // Temps restant sur le timer
        let timerActive = false; // Indique si le timer est actif
        let timerInterval = null; // Intervalle du timer
        
        // Variables pour le glisser-déposer de l'ordre de repêchage
        let draggingPick = null; // Élément de choix en cours de glissement

        // Configuration Firebase par défaut (à remplacer par la vôtre)
        const defaultFirebaseConfig = {
            databaseURL: "https://votre-projet-default-rtdb.firebaseio.com/"
        };

        // Données initiales des joueurs (utilisées si aucune donnée n'est importée ou dans le mode local)
        const defaultPlayers = [
            { id: 1, nom: "Tim Stützle", position: "C", age: 18, poids: 187, taille: "6'0\"", potentiel: 9, style: "Fabriquant de jeux", precision: "B", commentaire: "Excellent patineur avec des mains exceptionnelles", drafted: false },
            { id: 2, nom: "Quinton Byfield", position: "C", age: 18, poids: 220, taille: "6'5\"", potentiel: 8.5, style: "Attaquant Opportuniste", precision: "B", commentaire: "Grand centre dominant physiquement avec d'excellentes habiletés", drafted: false },
            { id: 3, nom: "Alexis Lafrenière", position: "LW", age: 18, poids: 193, taille: "6'1\"", potentiel: 9.5, style: "Marqueur élite", precision: "A", commentaire: "Le meilleur joueur de la cuvée, complet et intelligent", drafted: false },
            { id: 4, nom: "Jamie Drysdale", position: "D", age: 18, poids: 175, taille: "5'11\"", potentiel: 8.0, style: "Défenseur offensif", precision: "B+", commentaire: "Quart-arrière de puissance avec une excellente vision", drafted: false },
            { id: 5, nom: "Cole Perfetti", position: "C", age: 18, poids: 185, taille: "5'10\"", potentiel: 8.2, style: "Joueur cérébral", precision: "A-", commentaire: "Intelligence de jeu élite et mains rapides", drafted: false },
            { id: 6, nom: "Lucas Raymond", position: "RW", age: 18, poids: 180, taille: "5'10\"", potentiel: 8.3, style: "Skilled Forward", precision: "B+", commentaire: "Patineur fluide avec de bonnes aptitudes de passeur", drafted: false },
            { id: 7, nom: "Marco Rossi", position: "C", age: 18, poids: 183, taille: "5'9\"", potentiel: 8.1, style: "Two-way center", precision: "A", commentaire: "Travailleur acharné et habile dans les deux sens de la patinoire", drafted: false },
            { id: 8, nom: "Jack Quinn", position: "RW", age: 18, poids: 176, taille: "6'0\"", potentiel: 7.9, style: "Sniper", precision: "A+", commentaire: "Un excellent tir et un sens du but inné", drafted: false }
        ];

        // Liste des équipes par défaut
        const defaultTeams = [
            "Capitals", "Flyers", "Ducks", "Panthers", "Sabres", "Jets", "Oilers",
            "Stars", "Blackhawks", "Blues", "Sharks", "Rangers", "Canadiens",
            "Maple Leafs", "Bruins", "Predators", "Devils", "Kraken", "Islanders",
            "Flames", "Senators", "Canucks", "Lightning", "Red Wings", "Avalanche",
            "Penguins"
        ];

        // Initialise Firebase avec la configuration fournie
        function initializeFirebase() {
            const configText = document.getElementById('firebaseConfig').value.trim();
            
            if (!configText) {
                alert('Veuillez entrer votre configuration Firebase');
                return;
            }
            
            try {
                const config = JSON.parse(configText);
                
                // Sauvegarde la configuration dans le stockage local
                localStorage.setItem('firebase-config', configText);
                
                // Initialise l'application Firebase
                firebaseApp = firebase.initializeApp(config);
                database = firebase.database();
                
                setupRealtimeListeners(); // Met en place les écouteurs de base de données
                showLoginForm(); // Affiche le formulaire de connexion
                
            } catch (error) {
                alert('Erreur dans la configuration Firebase: ' + error.message);
                console.error('Firebase initialization error:', error);
            }
        }

        // Active le mode local (sans synchronisation Firebase)
        function useLocalMode() {
            useLocalStorage = true;
            localStorage.setItem('use-local-mode', 'true');
            // Initialise les données par défaut dans le stockage local si elles n'existent pas
            if (!localStorage.getItem('players')) {
                localStorage.setItem('players', JSON.stringify(defaultPlayers));
                localStorage.setItem('draftResults', JSON.stringify([]));
                localStorage.setItem('draftOrder', JSON.stringify(generateDefaultDraftOrder()));
                localStorage.setItem('gameState', JSON.stringify({ currentRound: 1, currentPick: 1 }));
                localStorage.setItem('timer', JSON.stringify({ duration: 300, remaining: 300, active: false }));
            }
            showLoginForm(); // Affiche le formulaire de connexion
            // Charge l'état initial depuis le stockage local
            players = JSON.parse(localStorage.getItem('players'));
            draftResults = JSON.parse(localStorage.getItem('draftResults'));
            draftOrder = JSON.parse(localStorage.getItem('draftOrder'));
            const gameState = JSON.parse(localStorage.getItem('gameState'));
            currentRound = gameState.currentRound;
            currentPick = gameState.currentPick;
            const timerState = JSON.parse(localStorage.getItem('timer'));
            timerDuration = timerState.duration;
            timerRemaining = timerState.remaining;
            timerActive = timerState.active;
            updateInterface(); // Met à jour l'interface
            updateConnectionStatus('local', 'Mode Local Actif'); // Met à jour le statut de connexion
            populateTeamSelectors(); // Remplit les sélecteurs d'équipe
        }

        // Affiche la section de configuration Firebase
        function showFirebaseConfig() {
            document.getElementById('loginForm').classList.add('hidden');
            document.getElementById('firebaseSetup').classList.remove('hidden');
        }

        // Affiche le formulaire de connexion
        function showLoginForm() {
            document.getElementById('firebaseSetup').classList.add('hidden');
            document.getElementById('mainApp').classList.add('hidden'); // Cache l'application principale
            document.getElementById('loginForm').classList.remove('hidden');
            
            if (useLocalStorage) {
                updateConnectionStatus('local', 'Mode Local Actif');
            } else if (firebaseApp) {
                updateConnectionStatus('connected', 'Connecté à Firebase');
            } else {
                updateConnectionStatus('connecting', 'Connexion à Firebase...');
            }
            populateTeamSelectors(); // Remplit toujours les sélecteurs d'équipe lors de l'affichage du formulaire de connexion
        }

        // Configure les listeners temps réel pour Firebase Realtime Database
        function setupRealtimeListeners() {
            if (!database || useLocalStorage) return; // Ne fait rien si pas de DB ou en mode local

            // Listener pour les joueurs
            database.ref('players').on('value', (snapshot) => {
                const data = snapshot.val();
                // Assure que les données sont un tableau pour une manipulation facile
                players = data ? Object.values(data) : []; 
                updateInterface();
                updateConnectionStatus('connected', 'Connecté à Firebase');
            }, (error) => {
                console.error("Erreur de lecture Firebase (joueurs): " + error.code);
                updateConnectionStatus('disconnected', 'Déconnecté de Firebase');
            });

            // Listener pour les résultats du repêchage
            database.ref('draftResults').on('value', (snapshot) => {
                const data = snapshot.val();
                draftResults = data ? Object.values(data) : [];
                updateInterface();
            }, (error) => {
                console.error("Erreur de lecture Firebase (résultats): " + error.code);
            });

            // Listener pour l'ordre de repêchage
            database.ref('draftOrder').on('value', (snapshot) => {
                const data = snapshot.val();
                draftOrder = data ? Object.values(data) : [];
                updateInterface();
            }, (error) => {
                console.error("Erreur de lecture Firebase (ordre): " + error.code);
            });

            // Listener pour l'état du jeu (ronde, choix actuels)
            database.ref('gameState').on('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    currentRound = data.currentRound || 1;
                    currentPick = data.currentPick || 1;
                    updateInterface();
                }
            }, (error) => {
                console.error("Erreur de lecture Firebase (état du jeu): " + error.code);
            });

            // Listener pour le timer
            database.ref('timer').on('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    timerDuration = data.duration || 300;
                    timerRemaining = data.remaining || 300;
                    timerActive = data.active || false;
                    
                    // Démarre le timer localement si non-admin et timer actif dans la DB
                    if (!isAdmin && timerActive && !timerInterval) {
                        startLocalTimer();
                    } else if (!timerActive && timerInterval) { // Arrête le timer si inactif dans la DB
                        clearInterval(timerInterval);
                        timerInterval = null;
                    }
                    updateTimerDisplay(); // Met à jour l'affichage du timer
                }
            }, (error) => {
                console.error("Erreur de lecture Firebase (timer): " + error.code);
            });

            // Listener pour le statut de connexion à Firebase
            database.ref('.info/connected').on('value', (snapshot) => {
                isConnected = snapshot.val();
                if (isConnected) {
                    updateConnectionStatus('connected', 'Connecté à Firebase');
                    // Récupère les données initiales si non déjà peuplées (pour éviter les écritures inutiles)
                    initializeDefaultData();
                } else {
                    updateConnectionStatus('disconnected', 'Déconnecté de Firebase');
                }
            });
        }

        // Met à jour le statut de connexion affiché dans l'interface
        function updateConnectionStatus(status, text) {
            const statusIndicator = document.getElementById('statusIndicator');
            const statusText = document.getElementById('statusText');
            const connectionStatusLogin = document.getElementById('connectionStatus');
            const connectionStatusMain = document.getElementById('connectionStatusMain');

            statusIndicator.className = `status-indicator status-${status}`;
            statusText.textContent = text;
            // Met à jour le statut dans le formulaire de connexion
            if (connectionStatusLogin) { // Vérifie si l'élément existe
                connectionStatusLogin.className = `connection-status ${status}`;
                connectionStatusLogin.querySelector('span:last-child').textContent = text;
            }
            // Met à jour le statut dans l'application principale
            if (connectionStatusMain) { // Vérifie si l'élément existe
                connectionStatusMain.className = `connection-status ${status}`;
                connectionStatusMain.querySelector('span:last-child').textContent = text;
            }
        }

        // Gère la connexion en tant qu'administrateur
        function loginAsAdmin() {
            const password = document.getElementById('adminPassword').value;
            if (password === 'lhss2020') { // Mot de passe admin codé en dur
                isAdmin = true;
                document.getElementById('loginForm').classList.add('hidden');
                document.getElementById('mainApp').classList.remove('hidden');
                document.getElementById('adminControls').classList.remove('hidden');
                document.getElementById('viewerInfo').classList.add('hidden');
                document.getElementById('statusIndicator').classList.add('status-admin');
                document.getElementById('statusIndicator').classList.remove('status-viewer');
                document.getElementById('statusText').textContent = 'Mode Admin';
                document.getElementById('adminDraftOrderControls').classList.remove('hidden'); // Affiche les contrôles admin pour l'ordre
                populateTeamSelectors(); // Assure que le sélecteur d'équipe admin est peuplé
                updateInterface();
            } else {
                alert('Mot de passe admin incorrect.');
            }
        }

        // Gère la connexion en tant que spectateur
        function loginAsViewer() {
            isAdmin = false;
            viewerSelectedTeam = document.getElementById('viewerTeamSelect').value;
            if (!viewerSelectedTeam) {
                alert('Veuillez sélectionner une équipe pour le mode spectateur.');
                return;
            }
            document.getElementById('loginForm').classList.add('hidden');
            document.getElementById('mainApp').classList.remove('hidden');
            document.getElementById('adminControls').classList.add('hidden'); // Cache les contrôles admin
            document.getElementById('viewerInfo').classList.remove('hidden'); // Affiche les infos spectateur
            document.getElementById('statusIndicator').classList.add('status-viewer');
            document.getElementById('statusIndicator').classList.remove('status-admin');
            document.getElementById('statusText').textContent = 'Mode Spectateur';
            document.getElementById('adminDraftOrderControls').classList.add('hidden'); // Cache les contrôles admin pour l'ordre
            document.getElementById('viewerTeamDisplay').textContent = `Visualisation pour : ${viewerSelectedTeam}`;
            updateInterface();
        }

        // Génère un ordre de repêchage par défaut (ex: 10 rondes, équipes en rotation)
        function generateDefaultDraftOrder() {
            const order = [];
            const teams = [...defaultTeams].sort(); // Trie les équipes pour un ordre cohérent
            const numRounds = 10; // Exemple: 10 rondes
            const picksPerRound = teams.length;

            for (let round = 1; round <= numRounds; round++) {
                if (round % 2 === 1) { // Rondes impaires: ordre normal (A-Z)
                    for (let i = 0; i < picksPerRound; i++) {
                        order.push({
                            round: round,
                            pick: (round - 1) * picksPerRound + (i + 1),
                            team: teams[i]
                        });
                    }
                } else { // Rondes paires: ordre inverse (Z-A)
                    for (let i = picksPerRound - 1; i >= 0; i--) {
                        order.push({
                            round: round,
                            pick: (round - 1) * picksPerRound + (picksPerRound - i),
                            team: teams[i]
                        });
                    }
                }
            }
            return order;
        }

        // Peuple les sélecteurs d'équipe (pour admin et spectateur)
        function populateTeamSelectors() {
            const adminTeamSelect = document.getElementById('teamSelect');
            const viewerTeamSelect = document.getElementById('viewerTeamSelect');

            // Vide les options existantes
            adminTeamSelect.innerHTML = '';
            viewerTeamSelect.innerHTML = '<option value="">Sélectionnez votre équipe (Spectateur)</option>';

            defaultTeams.sort().forEach(team => { // Trie les équipes pour l'affichage
                const optionAdmin = document.createElement('option');
                optionAdmin.value = team;
                optionAdmin.textContent = team;
                adminTeamSelect.appendChild(optionAdmin);

                const optionViewer = document.createElement('option');
                optionViewer.value = team;
                optionViewer.textContent = team;
                viewerTeamSelect.appendChild(optionViewer);
            });

            // Définit l'équipe actuellement sélectionnée pour l'admin
            adminTeamSelect.value = selectedTeam;
            // Définit l'équipe actuellement sélectionnée pour le spectateur
            viewerTeamSelect.value = viewerSelectedTeam;
        }

        // Initialise les données par défaut dans Firebase si elles n'existent pas
        function initializeDefaultData() {
            if (!database || !isConnected) return; // Exécute seulement si connecté à Firebase

            // Vérifie et pousse les joueurs par défaut
            database.ref('players').once('value', (snapshot) => {
                if (!snapshot.exists() || Object.keys(snapshot.val()).length === 0) {
                    database.ref('players').set(defaultPlayers)
                        .then(() => console.log("Joueurs par défaut ajoutés à Firebase."))
                        .catch(e => console.error("Erreur lors de l'ajout des joueurs par défaut:", e));
                }
            });

            // Vérifie et initialise les résultats du repêchage
            database.ref('draftResults').once('value', (snapshot) => {
                if (!snapshot.exists() || Object.keys(snapshot.val()).length === 0) {
                    database.ref('draftResults').set([])
                        .then(() => console.log("Résultats du repêchage initialisés dans Firebase."))
                        .catch(e => console.error("Erreur lors de l'initialisation des résultats:", e));
                }
            });

            // Vérifie et initialise l'ordre de repêchage
            database.ref('draftOrder').once('value', (snapshot) => {
                if (!snapshot.exists() || Object.keys(snapshot.val()).length === 0) {
                    database.ref('draftOrder').set(generateDefaultDraftOrder())
                        .then(() => console.log("Ordre de repêchage initialisé dans Firebase."))
                        .catch(e => console.error("Erreur lors de l'initialisation de l'ordre:", e));
                }
            });

            // Vérifie et initialise l'état du jeu
            database.ref('gameState').once('value', (snapshot) => {
                if (!snapshot.exists()) {
                    database.ref('gameState').set({ currentRound: 1, currentPick: 1, draftFinished: false })
                        .then(() => console.log("État du jeu initialisé dans Firebase."))
                        .catch(e => console.error("Erreur lors de l'initialisation de l'état du jeu:", e));
                }
            });

            // Vérifie et initialise le timer
            database.ref('timer').once('value', (snapshot) => {
                if (!snapshot.exists()) {
                    database.ref('timer').set({ duration: 300, remaining: 300, active: false })
                        .then(() => console.log("État du timer initialisé dans Firebase."))
                        .catch(e => console.error("Erreur lors de l'initialisation du timer:", e));
                }
            });
        }

        // Met à jour l'interface utilisateur en fonction des données actuelles
        function updateInterface() {
            renderPlayers();
            renderDraftResults();
            renderDraftSummary();
            renderDraftOrder(); // Affiche l'ordre de repêchage
            updateRoundAndPickDisplay();
            updateTeamSelection(); // Met à jour l'équipe sélectionnée dans le sélecteur admin
            updateAvailablePlayersCount(); // Met à jour le nombre de joueurs disponibles
        }

        // Met à jour le compteur de joueurs disponibles
        function updateAvailablePlayersCount() {
            const availableCount = players.filter(p => !p.drafted).length;
            document.getElementById('availableCount').textContent = availableCount;
            document.getElementById('playerCount').textContent = `Joueurs disponibles: ${availableCount} / ${players.length}`;
        }

        // Met à jour l'affichage de la ronde et du choix actuels
        function updateRoundAndPickDisplay() {
            const currentPickData = draftOrder.find(item => item.pick === currentPick && item.round === currentRound);
            const currentTeam = currentPickData ? currentPickData.team : 'Fin du repêchage';

            document.getElementById('roundInfo').textContent = `Ronde ${currentRound} - Choix #${currentPick}`;
            document.getElementById('currentPickerText').textContent = `Ronde ${currentRound} - Choix #${currentPick}`;
            document.getElementById('currentTeamText').textContent = `Équipe: ${currentTeam}`;

            // Surligne le choix actuel dans le tableau de l'ordre de repêchage
            const allPickItems = document.querySelectorAll('#draftOrderTable .pick-item');
            allPickItems.forEach(item => item.classList.remove('selected'));
            const currentPickElement = document.querySelector(`#pick-${currentRound}-${currentPick}`);
            if (currentPickElement) {
                currentPickElement.classList.add('selected');
                // Fait défiler l'élément actuel dans la vue
                currentPickElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        // Met à jour la sélection de l'équipe pour l'administrateur
        function updateTeamSelection() {
            const currentPickData = draftOrder.find(item => item.pick === currentPick && item.round === currentRound);
            if (isAdmin && currentPickData && document.getElementById('teamSelect')) {
                document.getElementById('teamSelect').value = currentPickData.team;
                selectedTeam = currentPickData.team;
            }
        }

        // Importe les joueurs depuis un fichier CSV
        function importPlayers(event) {
            if (!isAdmin) {
                alert("Vous n'êtes pas autorisé à importer des joueurs.");
                return;
            }
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            PapaParse.parse(file, {
                header: true,
                dynamicTyping: true, // Tente de convertir les nombres
                skipEmptyLines: true,
                complete: function(results) {
                    const importedPlayers = results.data.map((row, index) => ({
                        id: index + 1, // Assigne un ID unique
                        nom: row.Nom || 'Inconnu',
                        position: row.Position || 'ATT',
                        age: parseInt(row.Age) || 18,
                        poids: parseInt(row.Poids) || 180,
                        taille: row.Taille || "6'0\"",
                        potentiel: parseFloat(row.Potentiel) || 7.0,
                        style: row.Style || 'Polyvalent',
                        precision: row.Precision || 'C',
                        commentaire: row.Commentaire || '',
                        drafted: false // Les nouveaux joueurs ne sont pas repêchés
                    }));
                    players = importedPlayers;
                    if (useLocalStorage) {
                        localStorage.setItem('players', JSON.stringify(players));
                        updateInterface();
                    } else {
                        // Utilise .set() pour remplacer toutes les données existantes
                        database.ref('players').set(players)
                            .then(() => alert('Joueurs importés avec succès !'))
                            .catch(error => alert('Erreur lors de l\'importation des joueurs: ' + error.message));
                    }
                },
                error: function(err) {
                    alert('Erreur lors de l\'importation du fichier CSV des joueurs: ' + err.message);
                    console.error('Erreur de parse CSV:', err);
                }
            });
        }

        // Importe l'ordre de repêchage depuis un fichier CSV
        function importDraftOrder(event) {
            if (!isAdmin) {
                alert("Vous n'êtes pas autorisé à importer l'ordre de repêchage.");
                return;
            }
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            PapaParse.parse(file, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    // Vérifie la présence des colonnes nécessaires
                    if (!results.data[0] || !results.data[0].Ronde || !results.data[0].Choix || !results.data[0].Équipe) {
                        alert("Le fichier CSV de l'ordre de repêchage doit contenir les colonnes: Ronde, Choix, Équipe.");
                        return;
                    }
                    const importedOrder = results.data.map(row => ({
                        round: parseInt(row.Ronde),
                        pick: parseInt(row.Choix),
                        team: row.Équipe
                    })).filter(item => !isNaN(item.round) && !isNaN(item.pick) && item.team);

                    if (importedOrder.length > 0) {
                        draftOrder = importedOrder.sort((a, b) => a.pick - b.pick); // Trie par numéro de choix
                        if (useLocalStorage) {
                            localStorage.setItem('draftOrder', JSON.stringify(draftOrder));
                            updateInterface();
                        } else {
                            database.ref('draftOrder').set(draftOrder)
                                .then(() => alert('Ordre de repêchage importé avec succès !'))
                                .catch(error => alert('Erreur lors de l\'importation de l\'ordre: ' + error.message));
                        }
                        // Réinitialise la ronde et le choix actuels si un nouvel ordre est importé
                        currentRound = 1;
                        currentPick = 1;
                        updateGameState();
                    } else {
                        alert('Le fichier CSV de l\'ordre de repêchage est vide ou mal formaté.');
                    }
                },
                error: function(err) {
                    alert('Erreur lors de l\'importation du fichier CSV de l\'ordre de repêchage: ' + err.message);
                    console.error('Erreur de parse CSV:', err);
                }
            });
        }

        // Réinitialise tout le repêchage
        function resetDraft() {
            if (!isAdmin) {
                alert("Vous n'êtes pas autorisé à réinitialiser le repêchage.");
                return;
            }
            if (confirm("Êtes-vous sûr de vouloir réinitialiser TOUT le repêchage (joueurs repêchés, résultats, état) ? Cette action est irréversible.")) {
                players.forEach(p => p.drafted = false); // Marque tous les joueurs comme non repêchés
                draftResults = [];
                currentRound = 1;
                currentPick = 1;
                selectedPlayer = null;
                timerActive = false;
                timerRemaining = timerDuration;

                if (timerInterval) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                }

                if (database) {
                    const updates = {};
                    updates['/players'] = players; // Réinitialise le statut de repêchage de tous les joueurs
                    updates['/draftResults'] = [];
                    updates['/gameState'] = { currentRound: 1, currentPick: 1, draftFinished: false };
                    updates['/timer'] = { duration: timerDuration, remaining: timerDuration, active: false };
                    database.ref().update(updates)
                        .then(() => console.log("Repêchage réinitialisé dans Firebase."))
                        .catch(e => console.error("Erreur lors de la réinitialisation du repêchage dans Firebase:", e));
                } else if (useLocalStorage) {
                    localStorage.setItem('players', JSON.stringify(players));
                    localStorage.setItem('draftResults', JSON.stringify([]));
                    localStorage.setItem('gameState', JSON.stringify({ currentRound: 1, currentPick: 1, draftFinished: false }));
                    localStorage.setItem('timer', JSON.stringify({ duration: timerDuration, remaining: timerDuration, active: false }));
                }
                updateInterface();
                alert("Le repêchage a été réinitialisé.");
            }
        }

        // Met à jour l'état du jeu (ronde et choix actuels) dans Firebase/LocalStorage
        function updateGameState() {
            const gameState = { currentRound, currentPick };
            if (useLocalStorage) {
                localStorage.setItem('gameState', JSON.stringify(gameState));
                updateInterface();
            } else if (database) {
                database.ref('gameState').set(gameState).catch(error => console.error("Erreur mise à jour gameState:", error));
            }
        }

        // Met à jour la liste des joueurs dans Firebase/LocalStorage
        function updatePlayers() {
            if (useLocalStorage) {
                localStorage.setItem('players', JSON.stringify(players));
                updateInterface();
            } else if (database) {
                database.ref('players').set(players).catch(error => console.error("Erreur mise à jour players:", error));
            }
        }

        // Met à jour les résultats du repêchage dans Firebase/LocalStorage
        function updateDraftResults() {
            if (useLocalStorage) {
                localStorage.setItem('draftResults', JSON.stringify(draftResults));
                updateInterface();
            } else if (database) {
                database.ref('draftResults').set(draftResults).catch(error => console.error("Erreur mise à jour draftResults:", error));
            }
        }

        // Met à jour l'ordre de repêchage dans Firebase/LocalStorage
        function updateDraftOrder() {
            if (useLocalStorage) {
                localStorage.setItem('draftOrder', JSON.stringify(draftOrder));
                updateInterface();
            } else if (database) {
                database.ref('draftOrder').set(draftOrder).catch(error => console.error("Erreur mise à jour draftOrder:", error));
            }
        }

        // Met à jour l'état du timer dans Firebase/LocalStorage
        function updateTimerState() {
            const timerState = { duration: timerDuration, remaining: timerRemaining, active: timerActive };
            if (useLocalStorage) {
                localStorage.setItem('timer', JSON.stringify(timerState));
                updateTimerDisplay(); // Mise à jour locale
            } else if (database) {
                database.ref('timer').set(timerState).catch(error => console.error("Erreur mise à jour timer:", error));
            }
        }

        // Affiche la liste des joueurs disponibles et gère les filtres
        function renderPlayers() {
            const playersList = document.getElementById('playersList');
            playersList.innerHTML = ''; // Vide la liste
            document.getElementById('playersLoading').classList.add('hidden'); // Cache l'indicateur de chargement

            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const positionFilter = document.getElementById('positionFilter').value;

            // Collecte toutes les positions uniques pour le filtre
            const allPositions = new Set();
            players.forEach(p => allPositions.add(p.position));
            const positionFilterSelect = document.getElementById('positionFilter');
            // Vide les options existantes, mais garde "Toutes les positions"
            const currentOptions = Array.from(positionFilterSelect.options).map(o => o.value);
            Array.from(allPositions).sort().forEach(pos => {
                if (!currentOptions.includes(pos)) {
                    const option = document.createElement('option');
                    option.value = pos;
                    option.textContent = pos;
                    positionFilterSelect.appendChild(option);
                }
            });
            positionFilterSelect.value = positionFilter; // Re-sélectionne le filtre actuel

            // Filtre les joueurs
            const availablePlayers = players.filter(player => {
                const matchesSearch = player.nom.toLowerCase().includes(searchTerm) ||
                                      player.position.toLowerCase().includes(searchTerm) ||
                                      (player.commentaire && player.commentaire.toLowerCase().includes(searchTerm)) ||
                                      (player.style && player.style.toLowerCase().includes(searchTerm));
                const matchesPosition = positionFilter === '' || player.position === positionFilter;
                return !player.drafted && matchesSearch && matchesPosition; // N'affiche que les joueurs non repêchés
            });

            if (availablePlayers.length === 0) {
                playersList.innerHTML = '<div class="loading"><p>Aucun joueur disponible correspondant aux critères.</p></div>';
                return;
            }

            // Affiche les joueurs filtrés
            availablePlayers.forEach(player => {
                const playerDiv = document.createElement('div');
                playerDiv.classList.add('player-item');
                playerDiv.dataset.id = player.id; // Stocke l'ID du joueur
                
                playerDiv.innerHTML = `
                    <div class="player-name">${player.nom}
                        <span class="player-stats">
                            <span class="player-potential">Pot: ${player.potentiel}</span>
                            <span class="player-precision">Préc: ${player.precision}</span>
                        </span>
                    </div>
                    <div class="player-details">
                        ${player.position} | ${player.age} ans | ${player.taille} | ${player.poids} lbs
                    </div>
                `;
                playerDiv.onclick = () => selectPlayer(player); // Gère la sélection
                playersList.appendChild(playerDiv);
            });

            // Re-sélectionne le joueur précédemment sélectionné s'il est toujours disponible
            if (selectedPlayer && !selectedPlayer.drafted) {
                const el = document.querySelector(`.player-item[data-id="${selectedPlayer.id}"]`);
                if (el) el.classList.add('selected');
            } else {
                selectedPlayer = null; // Efface la sélection si le joueur est repêché ou introuvable
                document.getElementById('playerDetails').innerHTML = '<div class="loading"><p>Sélectionnez un joueur pour voir ses détails</p></div>';
            }
        }

        // Sélectionne un joueur et affiche ses détails
        function selectPlayer(player) {
            if (player.drafted) {
                alert('Ce joueur a déjà été repêché.');
                return;
            }
            // Supprime la classe 'selected' du joueur précédemment sélectionné
            const currentlySelected = document.querySelector('.player-item.selected');
            if (currentlySelected) {
                currentlySelected.classList.remove('selected');
            }

            // Ajoute la classe 'selected' au nouveau joueur
            const newSelected = document.querySelector(`.player-item[data-id="${player.id}"]`);
            if (newSelected) {
                newSelected.classList.add('selected');
            }
            
            selectedPlayer = player;
            displayPlayerDetails(player);
        }

        // Affiche les détails d'un joueur dans le panneau dédié
        function displayPlayerDetails(player) {
            const playerDetailsDiv = document.getElementById('playerDetails');
            playerDetailsDiv.innerHTML = `
                <h3>${player.nom}</h3>
                <p><strong>Position:</strong> ${player.position}</p>
                <p><strong>Âge:</strong> ${player.age}</p>
                <p><strong>Taille:</strong> ${player.taille}</p>
                <p><strong>Poids:</strong> ${player.poids} lbs</p>
                <p><strong>Potentiel:</strong> <span class="player-potential">${player.potentiel}</span></p>
                <p><strong>Précision:</strong> <span class="player-precision">${player.precision}</span></p>
                <p><strong>Style:</strong> ${player.style}</p>
                <p><strong>Commentaire:</strong> ${player.commentaire}</p>
                <br>
                ${isAdmin ? `<button onclick="draftPlayer()" class="btn btn-success" style="width: 100%;">🚀 Repêcher ce joueur</button>` : ''}
            `;
            // Affiche des informations supplémentaires si le joueur est repêché (pour les spectateurs)
            if (!isAdmin && viewerSelectedTeam) {
                const draftedResult = draftResults.find(r => r.playerId === player.id && r.team === viewerSelectedTeam);
                if (draftedResult) {
                     playerDetailsDiv.innerHTML += `<p style="margin-top: 10px; font-weight: bold; color: #10b981;">Repêché par votre équipe au choix #${draftedResult.pickNumber}!</p>`;
                } else if (player.drafted) {
                     playerDetailsDiv.innerHTML += `<p style="margin-top: 10px; font-weight: bold; color: #ef4444;">Ce joueur a été repêché par ${draftResults.find(r => r.playerId === player.id).team}.</p>`;
                }
            } else if (!isAdmin && player.drafted) {
                playerDetailsDiv.innerHTML += `<p style="margin-top: 10px; font-weight: bold; color: #ef4444;">Ce joueur a été repêché par ${draftResults.find(r => r.playerId === player.id).team}.</p>`;
            }
        }

        // Gère l'action de repêcher un joueur
        function draftPlayer() {
            if (!isAdmin) {
                alert('Vous devez être administrateur pour repêcher un joueur.');
                return;
            }
            if (!selectedPlayer) {
                alert('Veuillez sélectionner un joueur à repêcher.');
                return;
            }
            if (selectedPlayer.drafted) {
                alert('Ce joueur a déjà été repêché.');
                return;
            }

            const currentPickData = draftOrder.find(item => item.pick === currentPick && item.round === currentRound);
            if (!currentPickData) {
                alert('L\'ordre de repêchage est terminé ou non défini.');
                return;
            }

            // Vérifie si l'équipe sélectionnée manuellement correspond à l'équipe du tour
            if (document.getElementById('teamSelect').value !== currentPickData.team) {
                if (!confirm(`Attention: L'équipe actuelle qui repêche est ${currentPickData.team}, mais vous avez sélectionné ${document.getElementById('teamSelect').value}. Voulez-vous continuer avec l'équipe sélectionnée manuellement ?`)) {
                    return;
                }
            }
            selectedTeam = document.getElementById('teamSelect').value; // Utilise la valeur du sélecteur

            // Crée le nouvel objet de résultat de repêchage
            const newResult = {
                pickNumber: currentPick,
                round: currentRound,
                team: selectedTeam,
                playerId: selectedPlayer.id,
                playerName: selectedPlayer.nom,
                playerPosition: selectedPlayer.position,
                timestamp: new Date().toISOString()
            };

            // Marque le joueur comme repêché dans le tableau local 'players'
            const playerIndex = players.findIndex(p => p.id === selectedPlayer.id);
            if (playerIndex !== -1) {
                players[playerIndex].drafted = true;
            }

            draftResults.push(newResult); // Ajoute le résultat aux résultats locaux
            draftResults.sort((a, b) => a.pickNumber - b.pickNumber); // Trie les résultats par numéro de choix

            moveToNextPick(); // Passe au prochain choix

            // Réinitialise la sélection de joueur dans l'interface
            selectedPlayer = null;
            document.getElementById('playerDetails').innerHTML = '<div class="loading"><p>Sélectionnez un joueur pour voir ses détails</p></div>';

            // Met à jour les données dans Firebase/LocalStorage
            updatePlayers();
            updateDraftResults();
            updateGameState();
            resetTimer(); // Réinitialise le timer après un choix
        }

        // Passe au choix suivant dans l'ordre de repêchage
        function skipPick() {
            if (!isAdmin) {
                alert("Vous n'êtes pas autorisé à passer un tour.");
                return;
            }
            if (confirm('Êtes-vous sûr de vouloir passer le tour actuel ?')) {
                moveToNextPick();
                resetTimer(); // Réinitialise le timer après avoir passé
                updateGameState();
            }
        }

        // Logique pour avancer au prochain choix
        function moveToNextPick() {
            const nextPickIndex = draftOrder.findIndex(item => item.pick === currentPick && item.round === currentRound) + 1;
            if (nextPickIndex < draftOrder.length) {
                currentPick = draftOrder[nextPickIndex].pick;
                currentRound = draftOrder[nextPickIndex].round;
            } else {
                alert('Tous les choix du repêchage ont été effectués !');
                currentPick = draftOrder.length + 1; // Indique la fin du repêchage
                currentRound = Math.ceil((currentPick - 1) / defaultTeams.length); // Calcule la dernière ronde
            }
            updateGameState(); // Met à jour l'état du jeu dans la DB/LocalStorage
        }

        // Affiche les résultats du repêchage
        function renderDraftResults() {
            const draftResultsDiv = document.getElementById('draftResults');
            draftResultsDiv.innerHTML = '';

            if (draftResults.length === 0) {
                draftResultsDiv.innerHTML = '<div class="loading"><p>Aucun joueur repêché</p></div>';
                return;
            }

            // Filtre les résultats pour le mode spectateur
            const filteredResults = draftResults.filter(result => {
                if (isAdmin) return true; // Les admins voient tous les résultats
                return result.team === viewerSelectedTeam; // Les spectateurs voient seulement les choix de leur équipe
            });

            if (filteredResults.length === 0 && !isAdmin && viewerSelectedTeam) {
                 draftResultsDiv.innerHTML = `<div class="loading"><p>Aucun joueur repêché par ${viewerSelectedTeam} pour le moment.</p></div>`;
                 return;
            }

            // Affiche les résultats filtrés
            filteredResults.forEach(result => {
                const resultDiv = document.createElement('div');
                resultDiv.classList.add('draft-result');
                resultDiv.innerHTML = `
                    <div>
                        <strong>#${result.pickNumber} (Ronde ${result.round})</strong> - ${result.team}
                    </div>
                    <div>
                        ${result.playerName} (${result.playerPosition})
                    </div>
                `;
                draftResultsDiv.appendChild(resultDiv);
            });
        }

        // Affiche le tableau récapitulatif des choix par équipe
        function renderDraftSummary() {
            const summaryTableDiv = document.getElementById('summaryTable');
            
            // Calcule les choix par équipe
            const picksByTeam = {};
            defaultTeams.forEach(team => picksByTeam[team] = { totalPicks: 0, draftedPlayers: [] });

            draftResults.forEach(result => {
                if (picksByTeam[result.team]) {
                    picksByTeam[result.team].totalPicks++;
                    picksByTeam[result.team].draftedPlayers.push(result.playerName);
                }
            });

            let tableHTML = `
                <table class="table">
                    <thead>
                        <tr>
                            <th>Équipe</th>
                            <th>Choix faits</th>
                            <th>Joueurs Repêchés</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            const sortedTeams = Object.keys(picksByTeam).sort();
            sortedTeams.forEach(team => {
                const teamData = picksByTeam[team];
                tableHTML += `
                    <tr>
                        <td>${team}</td>
                        <td>${teamData.totalPicks}</td>
                        <td>${teamData.draftedPlayers.length > 0 ? teamData.draftedPlayers.join(', ') : 'Aucun'}</td>
                    </tr>
                `;
            });

            tableHTML += `
                    </tbody>
                </table>
            `;
            summaryTableDiv.innerHTML = tableHTML;
        }

        // Affiche l'ordre de repêchage et gère le glisser-déposer (Drag & Drop)
        function renderDraftOrder() {
            const draftOrderTableDiv = document.getElementById('draftOrderTable');
            draftOrderTableDiv.innerHTML = ''; // Vide le contenu

            if (draftOrder.length === 0) {
                draftOrderTableDiv.innerHTML = `
                    <div class="loading">
                        <p>Importez un fichier CSV avec l'ordre de repêchage</p>
                        <div style="margin-top: 10px; font-size: 0.8rem; color: #9ca3af;">
                            Format: Ronde, Choix, Équipe
                        </div>
                    </div>`;
                return;
            }

            // Crée un élément pour chaque choix dans l'ordre de repêchage
            draftOrder.forEach((item, index) => {
                const pickDiv = document.createElement('div');
                pickDiv.classList.add('pick-item');
                pickDiv.id = `pick-${item.round}-${item.pick}`; // ID unique pour chaque choix
                pickDiv.dataset.index = index; // Stocke l'index pour le glisser-déposer
                pickDiv.dataset.pickNumber = item.pick; // Stocke le numéro de choix

                if (isAdmin) {
                    pickDiv.setAttribute('draggable', true); // Rend l'élément draggable pour l'admin
                    pickDiv.addEventListener('dragstart', handleDragStart);
                    pickDiv.addEventListener('dragover', handleDragOver);
                    pickDiv.addEventListener('drop', handleDrop);
                    pickDiv.addEventListener('dragend', handleDragEnd);
                }

                pickDiv.innerHTML = `
                    <span class="pick-number">#${item.pick}</span>
                    <span>Ronde ${item.round}</span>
                    <span class="team-name">${item.team}</span>
                `;
                draftOrderTableDiv.appendChild(pickDiv);
            });
            updateRoundAndPickDisplay(); // Surligne le choix actuel après le rendu
        }
        
        // --- Fonctions de glisser-déposer (Drag and Drop) pour l'ordre de repêchage (Admin) ---
        function handleDragStart(e) {
            if (!isAdmin) return;
            draggingPick = e.target;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', e.target.dataset.index); // Stocke l'index de l'élément glissé
            e.target.classList.add('dragging');
        }

        function handleDragOver(e) {
            e.preventDefault(); // Nécessaire pour autoriser le drop
            if (!isAdmin) return;
            e.dataTransfer.dropEffect = 'move';
            const target = e.target.closest('.pick-item');
            if (target && target !== draggingPick) {
                const rect = target.getBoundingClientRect();
                const offsetY = e.clientY - rect.top;
                // Insère l'élément glissé avant ou après la cible en fonction de la position de la souris
                if (offsetY < rect.height / 2) {
                    target.parentNode.insertBefore(draggingPick, target);
                } else {
                    target.parentNode.insertBefore(draggingPick, target.nextSibling);
                }
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            if (!isAdmin) return;
            const originalIndex = parseInt(e.dataTransfer.getData('text/plain'));
            const droppedOnTarget = e.target.closest('.pick-item');

            if (droppedOnTarget && draggingPick && draggingPick !== droppedOnTarget) {
                const newIndex = Array.from(droppedOnTarget.parentNode.children).indexOf(draggingPick);
                
                // Effectue l'échange dans le tableau draftOrder
                const [movedItem] = draftOrder.splice(originalIndex, 1);
                draftOrder.splice(newIndex, 0, movedItem);

                // Réassigne les numéros de choix séquentiellement après l'échange
                draftOrder.forEach((item, idx) => {
                    item.pick = idx + 1; // Met à jour le numéro de choix en fonction de la nouvelle position
                    item.round = Math.ceil((idx + 1) / defaultTeams.length); // Recalcule la ronde
                });

                updateDraftOrder(); // Sauvegarde l'ordre mis à jour dans Firebase/LocalStorage
            }
        }

        function handleDragEnd(e) {
            if (!isAdmin) return;
            draggingPick.classList.remove('dragging');
            draggingPick = null;
        }
        
        // Fonction pour échanger manuellement deux choix par leur numéro (pour les contrôles admin)
        function swapDraftPicks() {
            if (!isAdmin) return;
            const pick1 = parseInt(document.getElementById('swapPick1').value);
            const pick2 = parseInt(document.getElementById('swapPick2').value);

            if (isNaN(pick1) || isNaN(pick2) || pick1 <= 0 || pick2 <= 0 || pick1 > draftOrder.length || pick2 > draftOrder.length) {
                alert('Veuillez entrer des numéros de choix valides.');
                return;
            }

            if (pick1 === pick2) {
                alert('Les numéros de choix doivent être différents.');
                return;
            }

            const index1 = pick1 - 1;
            const index2 = pick2 - 1;

            // Échange les éléments dans le tableau draftOrder
            [draftOrder[index1], draftOrder[index2]] = [draftOrder[index2], draftOrder[index1]];

            // Met à jour les numéros de choix et les rondes après l'échange
            draftOrder.forEach((item, idx) => {
                item.pick = idx + 1;
                item.round = Math.ceil((idx + 1) / defaultTeams.length);
            });

            updateDraftOrder(); // Sauvegarde l'ordre mis à jour dans Firebase/LocalStorage
            alert(`Choix #${pick1} et #${pick2} ont été échangés avec succès.`);
            document.getElementById('swapPick1').value = '';
            document.getElementById('swapPick2').value = '';
        }

        // Réinitialise l'ordre de repêchage à la configuration par défaut
        function resetDraftOrder() {
            if (!isAdmin) return;
            if (confirm('Êtes-vous sûr de vouloir réinitialiser l\'ordre de repêchage à la configuration par défaut ?')) {
                draftOrder = generateDefaultDraftOrder();
                updateDraftOrder(); // Sauvegarde dans Firebase/LocalStorage
                currentRound = 1;
                currentPick = 1;
                updateGameState();
                alert('L\'ordre de repêchage a été réinitialisé.');
            }
        }
        // --- Fin des fonctions de glisser-déposer ---

        // Exporte les résultats du repêchage au format CSV
        function exportToCSV() {
            if (!isAdmin) {
                alert("Vous n'êtes pas autorisé à exporter des données.");
                return;
            }
            if (draftResults.length === 0) {
                alert("Aucun joueur repêché à exporter.");
                return;
            }

            const header = ["Choix", "Ronde", "Équipe", "Joueur", "Position", "Timestamp"];
            const data = draftResults.map(r => [
                r.pickNumber,
                r.round,
                `"${r.team}"`, // Met entre guillemets pour gérer les virgules dans les noms d'équipe
                `"${r.playerName}"`, // Met entre guillemets
                `"${r.playerPosition}"`, // Met entre guillemets
                r.timestamp
            ]);

            let csvContent = header.join(",") + "\n";
            data.forEach(row => {
                csvContent += row.join(",") + "\n";
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            if (link.download !== undefined) { // Vérifie la prise en charge de l'attribut download
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', 'resultats_repechage_LHSS_2020.csv');
                link.style.visibility = 'hidden'; // Cache le lien
                document.body.appendChild(link);
                link.click(); // Déclenche le téléchargement
                document.body.removeChild(link); // Supprime le lien
            }
        }

        // Fonctions du timer
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // Met à jour l'affichage du timer
        function updateTimerDisplay() {
            const displayElement = isAdmin ? document.getElementById('timerDisplay') : document.getElementById('timerDisplayViewer');
            const statusElement = document.getElementById('timerStatusViewer');

            if (displayElement) {
                displayElement.textContent = formatTime(timerRemaining);
                if (timerRemaining <= 0) {
                    displayElement.classList.add('expired-timer');
                    if (!isAdmin && statusElement) statusElement.textContent = 'Temps écoulé !';
                } else {
                    displayElement.classList.remove('expired-timer');
                    if (!isAdmin && statusElement) statusElement.textContent = timerActive ? 'Compte à rebours en cours' : 'En pause';
                }
            }
        }

        // Démarre le compte à rebours local
        function startLocalTimer() {
            if (timerInterval) clearInterval(timerInterval); // Empêche les timers multiples
            timerInterval = setInterval(() => {
                if (timerRemaining > 0) {
                    timerRemaining--;
                    updateTimerDisplay();
                } else {
                    clearInterval(timerInterval);
                    timerInterval = null;
                    // Actions à la fin du timer (ex: passer le tour, alerter)
                    if (isAdmin) {
                        // alert('Temps écoulé !'); // L'admin peut être alerté
                        // Optionnel: skipPick(); // Passer automatiquement le tour
                    }
                    updateTimerState(); // S'assure que l'état est synchronisé après expiration
                }
            }, 1000);
        }

        // Définit la durée du timer
        function setTimer() {
            if (!isAdmin) {
                alert("Vous n'êtes pas autorisé à définir le timer.");
                return;
            }
            const minutes = parseInt(document.getElementById('timerMinutes').value);
            if (isNaN(minutes) || minutes < 1) {
                alert('Veuillez entrer un nombre de minutes valide (min 1).');
                return;
            }
            timerDuration = minutes * 60;
            timerRemaining = timerDuration;
            timerActive = false; // Met en pause après la définition
            updateTimerState(); // Synchronise la durée et le temps restant
            updateTimerDisplay();
        }

        // Démarre le timer
        function startTimer() {
            if (!isAdmin) {
                alert("Vous n'êtes pas autorisé à démarrer le timer.");
                return;
            }
            if (!timerActive) {
                timerActive = true;
                updateTimerState(); // Synchronise l'état actif
                startLocalTimer(); // Démarre le compte à rebours local
            }
        }

        // Met le timer en pause
        function pauseTimer() {
            if (!isAdmin) {
                alert("Vous n'êtes pas autorisé à mettre en pause le timer.");
                return;
            }
            if (timerActive) {
                timerActive = false;
                updateTimerState(); // Synchronise l'état inactif
                if (timerInterval) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                }
            }
        }

        // Réinitialise le timer à sa durée initiale
        function resetTimer() {
            if (!isAdmin) {
                alert("Vous n'êtes pas autorisé à réinitialiser le timer.");
                return;
            }
            timerRemaining = timerDuration;
            timerActive = false; // Met en pause lors de la réinitialisation
            updateTimerState(); // Synchronise tous les états
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            updateTimerDisplay();
        }

        // Initialisation de l'application au chargement de la page
        document.addEventListener('DOMContentLoaded', () => {
            // Vérifie la configuration Firebase sauvegardée ou la préférence de mode local
            const savedConfig = localStorage.getItem('firebase-config');
            const savedLocalMode = localStorage.getItem('use-local-mode');

            if (savedConfig) {
                document.getElementById('firebaseConfig').value = savedConfig;
                try {
                    const config = JSON.parse(savedConfig);
                    firebaseApp = firebase.initializeApp(config);
                    database = firebase.database();
                    setupRealtimeListeners();
                    updateConnectionStatus('connected', 'Connecté à Firebase');
                    showLoginForm(); // Affiche le formulaire de connexion après l'initialisation
                } catch (error) {
                    console.error('Échec de l\'analyse de la configuration Firebase sauvegardée:', error);
                    updateConnectionStatus('disconnected', 'Erreur config Firebase');
                    showFirebaseConfig(); // Affiche la configuration si elle est invalide
                }
            } else if (savedLocalMode === 'true') {
                useLocalMode();
            } else {
                showFirebaseConfig(); // Aucune configuration ou mode local, affiche la configuration
            }

            // Configure les écouteurs pour la recherche et les filtres
            document.getElementById('searchInput').addEventListener('input', updateInterface);
            document.getElementById('positionFilter').addEventListener('change', updateInterface);
            document.getElementById('teamSelect').addEventListener('change', (e) => {
                if (isAdmin) {
                    selectedTeam = e.target.value;
                }
            });
            document.getElementById('viewerTeamSelect').addEventListener('change', (e) => {
                if (!isAdmin) { // Met à jour uniquement en mode spectateur
                    viewerSelectedTeam = e.target.value;
                    document.getElementById('viewerTeamDisplay').textContent = `Visualisation pour : ${viewerSelectedTeam}`;
                    updateInterface(); // Re-rend l'interface pour refléter le nouveau filtre d'équipe
                }
            });
        });
    </script>
</body>
</html>

